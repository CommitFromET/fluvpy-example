<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary & JSON Polygon Surface Viewer (Z-Up)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #renderer {
            display: block;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 320px;
            z-index: 100;
        }

        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 350px;
            z-index: 100;
            font-size: 12px;
            line-height: 1.4;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 8px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-container label {
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
        }

        .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #ccc;
        }

        button {
            padding: 6px 12px;
            margin: 2px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 11px;
        }

        button:hover {
            background: #f0f0f0;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: #e74c3c;
            background: #fdf2f2;
            border: 1px solid #e74c3c;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            max-width: 500px;
        }

        .error h3 {
            margin-top: 0;
        }

        .error-details {
            background: #f8f8f8;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
            margin-top: 10px;
        }

        .stats-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .stats-section:last-child {
            border-bottom: none;
        }

        .stats-section h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #2c3e50;
        }

        .stats-item {
            margin-bottom: 4px;
            font-size: 11px;
            color: #555;
        }

        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 10px;
            max-width: 400px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
        }

        .github-info {
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .github-info h3 {
            color: #495057;
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .data-source-info {
            margin-bottom: 15px;
            padding: 10px;
            background: #e8f4fd;
            border-radius: 5px;
            border: 1px solid #bee5eb;
        }

        .data-source-info h3 {
            color: #0c5460;
            margin: 0 0 5px 0;
        }

        .data-source-info p {
            margin: 0;
            font-size: 11px;
            color: #0c5460;
        }

        .surface-stats {
            font-size: 10px;
            color: #666;
            margin-left: 4px;
        }

        .format-indicator {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .format-binary {
            background-color: #28a745;
            color: white;
        }

        .format-json {
            background-color: #007bff;
            color: white;
        }

        .performance-info {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 11px;
        }

        .url-list {
            font-family: monospace;
            font-size: 10px;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
        }

        .url-item {
            margin-bottom: 4px;
            word-break: break-all;
        }

        .load-status {
            margin-top: 8px;
            padding: 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .coordinate-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .coordinate-info h3 {
            margin: 0 0 5px 0;
            color: #856404;
            font-size: 13px;
        }

        .coordinate-info p {
            margin: 0;
            font-size: 11px;
            color: #856404;
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider-container label {
            display: block;
            font-size: 12px;
            color: #333;
            margin-bottom: 5px;
        }

        .slider-container input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .slider-value {
            font-size: 11px;
            color: #666;
            text-align: center;
        }

        .scale-control {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .scale-control h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" style="display: block;">
            <div class="loading-spinner"></div>
            <p>Loading 3D visualization from GitHub...</p>
            <p><small id="loading-detail">Initializing application...</small></p>
        </div>

        <div id="controls">
            <div class="coordinate-info">
                <h3>Coordinate System</h3>
                <p><strong>Z-axis Up</strong> (Right-handed coordinate system)</p>
                <p>X: East-West direction | Y: North-South direction | Z: Vertical up</p>
            </div>

            <div class="github-info" id="github-info">
                <h3>GitHub Data Source</h3>
                <p>Repository: <strong>CommitFromET/fluvpy-test-b</strong></p>
                <p>CDN Source: <span id="cdn-source">-</span></p>
                <p>Load Status: <span id="load-status" class="load-status status-loading">Loading...</span></p>
                <div class="url-list">
                    <div class="url-item">• raw.githubusercontent.com</div>
                    <div class="url-item">• cdn.jsdelivr.net</div>
                </div>
                <div class="performance-info">
                    <strong>Auto-loading:</strong><br>
                    Attempting to load envelope_1.bin from GitHub with CDN fallback
                </div>
            </div>

            <div class="control-group data-source-info" style="display: none;" id="data-source-info">
                <h3>Data Source</h3>
                <p>File: <span id="current-data-source">-</span>
                   <span id="file-format" class="format-indicator">-</span></p>
                <p>Size: <span id="file-size">-</span></p>
                <p>Load time: <span id="load-time">-</span></p>
            </div>

            <div class="control-group scale-control" style="display: none;" id="scale-controls">
                <h3>Vertical Scale Control</h3>
                <div class="slider-container">
                    <label for="z-scale-slider">Z-axis Scale Factor:</label>
                    <input type="range" id="z-scale-slider" min="0.1" max="5.0" step="0.1" value="1.0">
                    <div class="slider-value" id="z-scale-value">1.0x</div>
                </div>
                <button onclick="resetZScale()">Reset Scale</button>
            </div>

            <div class="control-group" id="visibility-controls" style="display: none;">
                <h3>Surface Visibility</h3>
                <!-- Dynamic surface controls will be added here -->
            </div>

            <div class="control-group" id="view-controls" style="display: none;">
                <h3>View Controls</h3>
                <button onclick="resetCamera()">Reset View</button>
                <button onclick="topView()">Top View (Z+)</button><br>
                <button onclick="bottomView()">Bottom View (Z-)</button>
                <button onclick="sideView()">Side View (Y+)</button><br>
                <button onclick="frontView()">Front View (X+)</button>
                <button onclick="backView()">Back View (X-)</button><br>
                <button onclick="toggleWireframe()">Wireframe</button>
                <button onclick="toggleDebug()">Debug</button>
            </div>
        </div>

        <div id="info" style="display: none;">
            <div class="stats-section">
                <h4>Model Information</h4>
                <div class="stats-item">Format: <span id="data-format">-</span></div>
                <div class="stats-item">Realization: <span id="realization">-</span></div>
                <div class="stats-item">Version: <span id="format-version">-</span></div>
                <div class="stats-item">Data Type: <span id="data-type">-</span></div>
                <div class="stats-item">Coordinate System: <strong>Z-Up (Right-handed)</strong></div>
                <div class="stats-item">Z-Scale: <span id="current-z-scale">1.0x</span></div>
            </div>

            <div class="stats-section">
                <h4>Surface Statistics</h4>
                <div class="stats-item">Total Surfaces: <span id="total-surfaces">-</span></div>
                <div class="stats-item">Total Vertices: <span id="total-vertices">-</span></div>
                <div class="stats-item">Total Faces: <span id="total-faces">-</span></div>
                <div id="surface-details"></div>
            </div>

            <div class="stats-section">
                <h4>Model Bounds</h4>
                <div class="stats-item">Size: <span id="model-size">-</span></div>
                <div class="stats-item">Center: <span id="model-center">-</span></div>
            </div>

            <div class="stats-section">
                <h4>Performance</h4>
                <div class="stats-item">Parsing time: <span id="parse-time">-</span></div>
                <div class="stats-item">Rendering time: <span id="render-time">-</span></div>
                <div class="stats-item">Memory usage: <span id="memory-usage">-</span></div>
            </div>

            <div class="stats-section">
                <h4>Controls</h4>
                <div class="stats-item">• Left drag: Rotate around Z-axis</div>
                <div class="stats-item">• Scroll: Zoom in/out</div>
                <div class="stats-item">• Use preset views above</div>
                <div class="stats-item">• Adjust Z-scale with slider</div>
            </div>
        </div>

        <div id="debug" style="display: none;">
            <div id="debug-content">Debug info will appear here</div>
        </div>

        <canvas id="renderer"></canvas>
    </div>

    <script>
        // Global error handling
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
            showError('JavaScript Error', e.error.message, e.error.stack);
        });

        // GitHub URLs for data loading
        const GITHUB_URLS = [
            'https://raw.githubusercontent.com/CommitFromET/fluvpy-example/master/web_data/data4.bin',
            'https://cdn.jsdelivr.net/gh/CommitFromET/fluvpy-example@master/web_data/data4.bin'
        ];

        // Global variables
        let scene, camera, renderer;
        let surfaceGroups = {};
        let wireframeMode = false;
        let polygonData = null;
        let dataBounds = null;
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        // Changed to Z-axis up angle variable naming
        let azimuth = 0;    // Horizontal rotation angle (around Z-axis)
        let elevation = 0;  // Vertical angle (from XY plane upward)
        let cameraRadius = 1000;
        let debugMode = false;
        let fileMetadata = {};
        let zScale = 1.0;   // Z-axis scale factor
        let axisGroup = null;  // For coordinate axes
        let gridGroup = null;  // For grid lines

        // Show error message
        function showError(title, message, details = '') {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            loading.innerHTML = `
                <div class="error">
                    <h3>${title}</h3>
                    <p>${message}</p>
                    ${details ? `<div class="error-details">${details}</div>` : ''}
                    <br>
                    <p><strong>Possible solutions:</strong></p>
                    <ul style="text-align: left; font-size: 12px;">
                        <li>Check your internet connection</li>
                        <li>Try refreshing the page</li>
                        <li>GitHub repository may be temporarily unavailable</li>
                        <li>Check browser console for more error information</li>
                    </ul>
                    <button onclick="hideError()" style="margin-top: 10px;">Close</button>
                </div>
            `;
        }

        function hideError() {
            document.getElementById('loading').style.display = 'none';
        }

        // Dynamic Three.js loading function
        function loadThreeJS() {
            return new Promise((resolve, reject) => {
                const cdnUrls = [
                    'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
                    'https://unpkg.com/three@0.128.0/build/three.min.js',
                    'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js'
                ];

                let currentIndex = 0;

                function tryLoad() {
                    if (currentIndex >= cdnUrls.length) {
                        reject(new Error('All CDN sources failed to load Three.js'));
                        return;
                    }

                    const script = document.createElement('script');
                    script.src = cdnUrls[currentIndex];
                    script.onload = () => {
                        console.log(`Three.js loaded from: ${cdnUrls[currentIndex]}`);
                        resolve();
                    };
                    script.onerror = () => {
                        console.warn(`Failed to load from: ${cdnUrls[currentIndex]}`);
                        currentIndex++;
                        tryLoad();
                    };
                    document.head.appendChild(script);
                }

                tryLoad();
            });
        }

        // Check if Three.js is loaded
        function checkThreeJS() {
            return typeof THREE !== 'undefined';
        }

        // Debug logging
        function debugLog(message) {
            console.log('[DEBUG]', message);
            if (debugMode) {
                const debugContent = document.getElementById('debug-content');
                if (debugContent) {
                    debugContent.innerHTML += message + '<br>';
                    debugContent.scrollTop = debugContent.scrollHeight;
                }
            }
        }

        // Z-scale control functions
        function setupZScaleControl() {
            const slider = document.getElementById('z-scale-slider');
            const valueDisplay = document.getElementById('z-scale-value');

            slider.addEventListener('input', function() {
                zScale = parseFloat(this.value);
                valueDisplay.textContent = zScale.toFixed(1) + 'x';
                document.getElementById('current-z-scale').textContent = zScale.toFixed(1) + 'x';
                applyZScale();
                debugLog(`Z-scale changed to: ${zScale.toFixed(1)}x`);
            });
        }

        function resetZScale() {
            zScale = 1.0;
            document.getElementById('z-scale-slider').value = '1.0';
            document.getElementById('z-scale-value').textContent = '1.0x';
            document.getElementById('current-z-scale').textContent = '1.0x';
            applyZScale();
            debugLog('Z-scale reset to 1.0x');
        }

        function applyZScale() {
            if (!polygonData) return;

            Object.values(surfaceGroups).forEach(group => {
                group.scale.z = zScale;
            });

            // Update coordinate axes with new scale
            if (axisGroup) {
                updateCoordinateAxes();
            }

            updateCameraPosition();
        }

        // Validate data structure
        function validateData(data) {
            if (!data || typeof data !== 'object') {
                throw new Error('Invalid data structure: not an object');
            }

            if (!data.metadata) {
                throw new Error('Missing metadata section');
            }

            if (!data.surfaces || !Array.isArray(data.surfaces)) {
                throw new Error('Missing or invalid surfaces array');
            }

            // Validate each surface
            for (let i = 0; i < data.surfaces.length; i++) {
                const surface = data.surfaces[i];
                if (!surface.vertices || !Array.isArray(surface.vertices)) {
                    throw new Error(`Surface ${i}: missing or invalid vertices array`);
                }
                if (!surface.faces || !Array.isArray(surface.faces)) {
                    throw new Error(`Surface ${i}: missing or invalid faces array`);
                }
                if (!surface.facies_name) {
                    throw new Error(`Surface ${i}: missing facies_name`);
                }
            }

            debugLog(`Validation passed: ${data.surfaces.length} surfaces found`);
            return true;
        }

        // Calculate global bounds
        function calculateGlobalBounds(data) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            data.surfaces.forEach(surface => {
                surface.vertices.forEach(vertex => {
                    const [x, y, z] = vertex;
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);
                });
            });

            if (!data.metadata.global_bounds) {
                data.metadata.global_bounds = {
                    min: { x: minX, y: minY, z: minZ },
                    max: { x: maxX, y: maxY, z: maxZ },
                    size: {
                        x: maxX - minX,
                        y: maxY - minY,
                        z: maxZ - minZ
                    }
                };
            }

            debugLog(`Global bounds calculated: ${JSON.stringify(data.metadata.global_bounds.size)}`);
        }

        // Update data bounds for camera
        function updateDataBounds() {
            if (!polygonData || !polygonData.metadata.global_bounds) return;

            const bounds = polygonData.metadata.global_bounds;
            dataBounds = {
                min: bounds.min,
                max: bounds.max,
                center: {
                    x: (bounds.min.x + bounds.max.x) / 2,
                    y: (bounds.min.y + bounds.max.y) / 2,
                    z: (bounds.min.z + bounds.max.z) / 2
                },
                size: bounds.size
            };

            const maxSize = Math.max(bounds.size.x, bounds.size.y, bounds.size.z);
            cameraRadius = maxSize * 1.5;
            debugLog(`Camera radius set to: ${cameraRadius.toFixed(1)}`);
        }

        // Update info panel
        function updateInfoPanel() {
            if (!polygonData) return;

            const meta = polygonData.metadata;
            const stats = meta.total_statistics || {};

            // Model info
            document.getElementById('data-format').textContent = fileMetadata.type.toUpperCase();
            document.getElementById('realization').textContent = meta.realization || '-';
            document.getElementById('format-version').textContent = meta.format_version || '-';
            document.getElementById('data-type').textContent = meta.data_type || '-';
            document.getElementById('current-z-scale').textContent = zScale.toFixed(1) + 'x';

            // Surface stats
            document.getElementById('total-surfaces').textContent = (stats.total_surfaces || polygonData.surfaces.length).toLocaleString();
            document.getElementById('total-vertices').textContent = (stats.total_vertices || 0).toLocaleString();
            document.getElementById('total-faces').textContent = (stats.total_faces || 0).toLocaleString();

            // Model bounds
            if (meta.global_bounds) {
                const bounds = meta.global_bounds;
                document.getElementById('model-size').textContent =
                    `${bounds.size.x.toFixed(0)}×${bounds.size.y.toFixed(0)}×${bounds.size.z.toFixed(0)}`;
                document.getElementById('model-center').textContent =
                    `(${((bounds.min.x + bounds.max.x) / 2).toFixed(1)}, ${((bounds.min.y + bounds.max.y) / 2).toFixed(1)}, ${((bounds.min.z + bounds.max.z) / 2).toFixed(1)})`;
            }

            // Performance info
            document.getElementById('parse-time').textContent = meta.parse_time_ms ? `${meta.parse_time_ms.toFixed(1)}ms` : '-';
            document.getElementById('render-time').textContent = fileMetadata.renderTime ? `${fileMetadata.renderTime.toFixed(1)}ms` : '-';

            // Estimate memory usage
            const totalVertices = stats.total_vertices || 0;
            const totalFaces = stats.total_faces || 0;
            const estimatedMemoryMB = ((totalVertices * 12) + (totalFaces * 12)) / (1024 * 1024);
            document.getElementById('memory-usage').textContent = `~${estimatedMemoryMB.toFixed(1)}MB`;

            // Surface details
            const detailsDiv = document.getElementById('surface-details');
            detailsDiv.innerHTML = '';
            polygonData.surfaces.forEach(surface => {
                const div = document.createElement('div');
                div.className = 'stats-item';
                div.innerHTML = `${surface.facies_name}: ${surface.statistics.vertex_count.toLocaleString()} vertices, ${surface.statistics.face_count.toLocaleString()} faces`;
                detailsDiv.appendChild(div);
            });

            // Update file info
            document.getElementById('current-data-source').textContent = `${fileMetadata.name} (${fileMetadata.source})`;
            document.getElementById('file-format').textContent = fileMetadata.type.toUpperCase();
            document.getElementById('file-format').className = `format-indicator format-${fileMetadata.type}`;
            document.getElementById('file-size').textContent = `${(fileMetadata.size / 1024 / 1024).toFixed(2)} MB`;
            document.getElementById('load-time').textContent = `${fileMetadata.loadTime.toFixed(0)}ms`;
        }

        // Create visibility controls
        function createVisibilityControls() {
            if (!polygonData) return;

            const controlsDiv = document.getElementById('visibility-controls');
            controlsDiv.innerHTML = '<h3>Surface Visibility</h3>';

            polygonData.surfaces.forEach((surface, index) => {
                const container = document.createElement('div');
                container.className = 'checkbox-container';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `surface-${index}`;
                checkbox.checked = true;
                checkbox.addEventListener('change', (e) => {
                    if (surfaceGroups[surface.facies_name]) {
                        surfaceGroups[surface.facies_name].visible = e.target.checked;
                    }
                });

                const colorIndicator = document.createElement('div');
                colorIndicator.className = 'color-indicator';
                colorIndicator.style.backgroundColor = surface.color;

                const label = document.createElement('label');
                label.setAttribute('for', `surface-${index}`);
                label.textContent = surface.facies_name;

                const stats = document.createElement('span');
                stats.className = 'surface-stats';
                stats.textContent = `(${surface.statistics.face_count} faces)`;

                container.appendChild(checkbox);
                container.appendChild(colorIndicator);
                container.appendChild(label);
                container.appendChild(stats);

                controlsDiv.appendChild(container);
            });

            controlsDiv.style.display = 'block';
        }

        // Initialize Three.js scene
        function initScene() {
            debugLog('Initializing scene...');

            if (!window.THREE) {
                throw new Error('THREE.js is not available');
            }

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);

            // Renderer
            const canvas = document.getElementById('renderer');
            if (!canvas) {
                throw new Error('Canvas element not found');
            }

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1000, 1000, 1000);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1000, -1000, 500);
            scene.add(directionalLight2);

            // Controls
            setupControls();
            setupZScaleControl();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            debugLog('Scene initialized successfully');
        }

        // Enhanced orbit controls
        function setupControls() {
            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;

            // Updated for Z-axis up angle control
            azimuth += deltaX * 0.01;  // Horizontal rotation (around Z-axis)
            elevation -= deltaY * 0.01; // Vertical rotation (elevation angle)

            // Limit elevation range (-90° to +90°)
            elevation = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, elevation));

            updateCameraPosition();

            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onMouseWheel(event) {
            const scale = event.deltaY > 0 ? 1.1 : 0.9;
            cameraRadius *= scale;
            cameraRadius = Math.max(10, Math.min(5000, cameraRadius));
            updateCameraPosition();
            event.preventDefault();
        }

        // Modified for Z-axis up camera position calculation
        function updateCameraPosition() {
            if (!dataBounds) return;

            const centerX = dataBounds.center.x;
            const centerY = dataBounds.center.y;
            const centerZ = dataBounds.center.z;

            // Z-axis up spherical coordinate system
            // elevation: angle from XY plane upward (-π/2 to π/2)
            // azimuth: horizontal rotation around Z-axis
            camera.position.x = centerX + cameraRadius * Math.cos(elevation) * Math.cos(azimuth);
            camera.position.y = centerY + cameraRadius * Math.cos(elevation) * Math.sin(azimuth);
            camera.position.z = centerZ + cameraRadius * Math.sin(elevation);

            camera.lookAt(centerX, centerY, centerZ);

            // Set camera's up vector to positive Z-axis
            camera.up.set(0, 0, 1);
        }

        // Create 3D visualization
        function createVisualization() {
            if (!polygonData) return;

            const renderStart = performance.now();
            debugLog('Creating 3D visualization from surface data...');

            // Clear existing surfaces
            Object.values(surfaceGroups).forEach(group => {
                scene.remove(group);
            });
            surfaceGroups = {};

            // Create surfaces
            polygonData.surfaces.forEach(surfaceData => {
                createSurfaceFromData(surfaceData);
            });

            calculateGlobalBounds(polygonData);
            updateDataBounds();
            resetCamera();
            addCoordinateHelpers();
            createVisibilityControls();
            updateInfoPanel();

            fileMetadata.renderTime = performance.now() - renderStart;

            // Show UI elements
            document.getElementById('data-source-info').style.display = 'block';
            document.getElementById('scale-controls').style.display = 'block';
            document.getElementById('view-controls').style.display = 'block';
            document.getElementById('info').style.display = 'block';

            debugLog('3D visualization created successfully');
        }

        // Create surface mesh from data
        function createSurfaceFromData(surfaceData) {
            const { facies_name, vertices, faces, color } = surfaceData;

            debugLog(`Creating surface: ${facies_name} with ${vertices.length} vertices, ${faces.length} faces`);

            // Create geometry
            const geometry = new THREE.BufferGeometry();

            // Convert vertices to Float32Array
            const verticesArray = new Float32Array(vertices.length * 3);
            for (let i = 0; i < vertices.length; i++) {
                verticesArray[i * 3] = vertices[i][0];
                verticesArray[i * 3 + 1] = vertices[i][1];
                verticesArray[i * 3 + 2] = vertices[i][2];
            }

            // Convert faces to indices array
            const indicesArray = new Uint32Array(faces.length * 3);
            for (let i = 0; i < faces.length; i++) {
                indicesArray[i * 3] = faces[i][0];
                indicesArray[i * 3 + 1] = faces[i][1];
                indicesArray[i * 3 + 2] = faces[i][2];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(verticesArray, 3));
            geometry.setIndex(new THREE.BufferAttribute(indicesArray, 1));
            geometry.computeVertexNormals();

            // Create material
            const material = new THREE.MeshLambertMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: false,
                opacity: 1.0
            });

            // Create mesh
            const mesh = new THREE.Mesh(geometry, material);

            // Create group for this surface
            const group = new THREE.Group();
            group.add(mesh);
            group.name = facies_name;

            surfaceGroups[facies_name] = group;
            scene.add(group);

            debugLog(`Surface ${facies_name} created successfully`);
        }


        function resetCamera() {
            if (!dataBounds) return;
            azimuth = Math.PI / 4;
            elevation = Math.PI / 6;
            cameraRadius = Math.max(dataBounds.size.x, dataBounds.size.y, dataBounds.size.z) * 1.8;
            updateCameraPosition();
            debugLog('Camera reset to default view (Z-up)');
        }

        function topView() {
            if (!dataBounds) return;
            azimuth = 0;
            elevation = Math.PI / 2 - 0.1;
            cameraRadius = Math.max(dataBounds.size.x, dataBounds.size.y) * 1.2;
            updateCameraPosition();
            debugLog('Camera set to top view (Z+)');
        }

        function bottomView() {
            if (!dataBounds) return;
            azimuth = 0;
            elevation = -Math.PI / 2 + 0.1;
            cameraRadius = Math.max(dataBounds.size.x, dataBounds.size.y) * 1.2;
            updateCameraPosition();
            debugLog('Camera set to bottom view (Z-)');
        }

        function sideView() {
            if (!dataBounds) return;
            azimuth = Math.PI / 2;
            elevation = 0;
            cameraRadius = Math.max(dataBounds.size.x, dataBounds.size.z) * 1.5;
            updateCameraPosition();
            debugLog('Camera set to side view (Y+)');
        }

        function frontView() {
            if (!dataBounds) return;
            azimuth = 0;   // 0 degrees, looking along positive X direction
            elevation = 0; // horizontal
            cameraRadius = Math.max(dataBounds.size.y, dataBounds.size.z) * 1.5;
            updateCameraPosition();
            debugLog('Camera set to front view (X+)');
        }

        function backView() {
            if (!dataBounds) return;
            azimuth = Math.PI;
            elevation = 0;
            cameraRadius = Math.max(dataBounds.size.y, dataBounds.size.z) * 1.5;
            updateCameraPosition();
            debugLog('Camera set to back view (X-)');
        }

        // Create text texture
        function createTextTexture(text, fontSize = 64, color = '#000000') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            canvas.width = 256;
            canvas.height = 128;

            context.font = `${fontSize}px Arial`;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            return texture;
        }

        // Enhanced coordinate axis display for Z-axis up with detailed labeling
        function addCoordinateHelpers() {
            if (!dataBounds) return;

            // Remove existing axis group if it exists
            if (axisGroup) {
                scene.remove(axisGroup);
            }
            if (gridGroup) {
                scene.remove(gridGroup);
            }

            axisGroup = new THREE.Group();
            gridGroup = new THREE.Group();

            const bounds = dataBounds;
            const axisLength = Math.min(bounds.size.x, bounds.size.y, bounds.size.z) * 0.4;
            const arrowLength = axisLength * 0.1;
            const arrowRadius = axisLength * 0.02;

            // Origin set at data bottom center
            const origin = {
                x: bounds.center.x,
                y: bounds.center.y,
                z: bounds.min.z - bounds.size.z * 0.1
            };

            // X-axis (red) - East-West direction
            const xAxisGroup = new THREE.Group();
            const xGeometry = new THREE.CylinderGeometry(axisLength * 0.005, axisLength * 0.005, axisLength, 8);
            const xMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const xAxis = new THREE.Mesh(xGeometry, xMaterial);
            xAxis.position.set(origin.x + axisLength / 2, origin.y, origin.z);
            xAxis.rotation.z = -Math.PI / 2;  // horizontal direction
            xAxisGroup.add(xAxis);

            const xArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const xArrow = new THREE.Mesh(xArrowGeometry, xMaterial);
            xArrow.position.set(origin.x + axisLength, origin.y, origin.z);
            xArrow.rotation.z = -Math.PI / 2;
            xAxisGroup.add(xArrow);

            const xLabelTexture = createTextTexture('X (East)', 36, '#ff0000');
            const xLabelMaterial = new THREE.SpriteMaterial({ map: xLabelTexture });
            const xLabel = new THREE.Sprite(xLabelMaterial);
            xLabel.position.set(origin.x + axisLength * 1.3, origin.y, origin.z);
            xLabel.scale.set(axisLength * 0.4, axisLength * 0.2, 1);
            xAxisGroup.add(xLabel);

            // Add X-axis coordinate values
            const xSteps = 5;
            const xStepSize = bounds.size.x / xSteps;
            for (let i = 0; i <= xSteps; i++) {
                const xValue = bounds.min.x + i * xStepSize;
                const xPos = origin.x + (xValue - bounds.center.x);

                if (Math.abs(xValue - bounds.center.x) > bounds.size.x * 0.1) { // Skip center value to avoid overlap
                    // Grid line
                    const gridGeometry = new THREE.BufferGeometry();
                    const gridVertices = new Float32Array([
                        xPos, bounds.min.y, origin.z,
                        xPos, bounds.max.y, origin.z
                    ]);
                    gridGeometry.setAttribute('position', new THREE.BufferAttribute(gridVertices, 3));
                    const gridMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc, opacity: 0.3, transparent: true });
                    const gridLine = new THREE.Line(gridGeometry, gridMaterial);
                    gridGroup.add(gridLine);
                }

                // Value label
                const valueTexture = createTextTexture(xValue.toFixed(0), 24, '#666666');
                const valueMaterial = new THREE.SpriteMaterial({ map: valueTexture });
                const valueLabel = new THREE.Sprite(valueMaterial);
                valueLabel.position.set(xPos, origin.y - bounds.size.y * 0.1, origin.z);
                valueLabel.scale.set(axisLength * 0.2, axisLength * 0.1, 1);
                xAxisGroup.add(valueLabel);
            }

            axisGroup.add(xAxisGroup);

            // Y-axis (green) - North-South direction
            const yAxisGroup = new THREE.Group();
            const yGeometry = new THREE.CylinderGeometry(axisLength * 0.005, axisLength * 0.005, axisLength, 8);
            const yMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const yAxis = new THREE.Mesh(yGeometry, yMaterial);
            yAxis.position.set(origin.x, origin.y + axisLength / 2, origin.z);
            yAxis.rotation.x = Math.PI / 2;  // along Y direction
            yAxisGroup.add(yAxis);

            const yArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const yArrow = new THREE.Mesh(yArrowGeometry, yMaterial);
            yArrow.position.set(origin.x, origin.y + axisLength, origin.z);
            yArrow.rotation.x = Math.PI / 2;
            yAxisGroup.add(yArrow);

            const yLabelTexture = createTextTexture('Y (North)', 36, '#00ff00');
            const yLabelMaterial = new THREE.SpriteMaterial({ map: yLabelTexture });
            const yLabel = new THREE.Sprite(yLabelMaterial);
            yLabel.position.set(origin.x, origin.y + axisLength * 1.3, origin.z);
            yLabel.scale.set(axisLength * 0.4, axisLength * 0.2, 1);
            yAxisGroup.add(yLabel);

            // Add Y-axis coordinate values
            const ySteps = 5;
            const yStepSize = bounds.size.y / ySteps;
            for (let i = 0; i <= ySteps; i++) {
                const yValue = bounds.min.y + i * yStepSize;
                const yPos = origin.y + (yValue - bounds.center.y);

                if (Math.abs(yValue - bounds.center.y) > bounds.size.y * 0.1) {
                    // Grid line
                    const gridGeometry = new THREE.BufferGeometry();
                    const gridVertices = new Float32Array([
                        bounds.min.x, yPos, origin.z,
                        bounds.max.x, yPos, origin.z
                    ]);
                    gridGeometry.setAttribute('position', new THREE.BufferAttribute(gridVertices, 3));
                    const gridMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc, opacity: 0.3, transparent: true });
                    const gridLine = new THREE.Line(gridGeometry, gridMaterial);
                    gridGroup.add(gridLine);
                }

                // Value label
                const valueTexture = createTextTexture(yValue.toFixed(0), 24, '#666666');
                const valueMaterial = new THREE.SpriteMaterial({ map: valueTexture });
                const valueLabel = new THREE.Sprite(valueMaterial);
                valueLabel.position.set(origin.x - bounds.size.x * 0.1, yPos, origin.z);
                valueLabel.scale.set(axisLength * 0.2, axisLength * 0.1, 1);
                yAxisGroup.add(valueLabel);
            }

            axisGroup.add(yAxisGroup);

            // Z-axis (blue) - Vertical up
            const zAxisGroup = new THREE.Group();
            const zGeometry = new THREE.CylinderGeometry(axisLength * 0.005, axisLength * 0.005, axisLength, 8);
            const zMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
            const zAxis = new THREE.Mesh(zGeometry, zMaterial);
            zAxis.position.set(origin.x, origin.y, origin.z + axisLength / 2);
            // Z-axis doesn't need rotation, it's already vertical
            zAxisGroup.add(zAxis);

            const zArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const zArrow = new THREE.Mesh(zArrowGeometry, zMaterial);
            zArrow.position.set(origin.x, origin.y, origin.z + axisLength);
            zAxisGroup.add(zArrow);

            const zLabelTexture = createTextTexture('Z (Up)', 36, '#0000ff');
            const zLabelMaterial = new THREE.SpriteMaterial({ map: zLabelTexture });
            const zLabel = new THREE.Sprite(zLabelMaterial);
            zLabel.position.set(origin.x, origin.y, origin.z + axisLength * 1.3);
            zLabel.scale.set(axisLength * 0.4, axisLength * 0.2, 1);
            zAxisGroup.add(zLabel);

            // Add Z-axis coordinate values
            const zSteps = 5;
            const zStepSize = bounds.size.z / zSteps;
            for (let i = 0; i <= zSteps; i++) {
                const zValue = bounds.min.z + i * zStepSize;
                const zPos = origin.z + (zValue - origin.z) + bounds.size.z * 0.1 + (i * zStepSize);

                // Value label
                const valueTexture = createTextTexture(zValue.toFixed(0), 24, '#666666');
                const valueMaterial = new THREE.SpriteMaterial({ map: valueTexture });
                const valueLabel = new THREE.Sprite(valueMaterial);
                valueLabel.position.set(origin.x + bounds.size.x * 0.1, origin.y, zPos);
                valueLabel.scale.set(axisLength * 0.2, axisLength * 0.1, 1);
                zAxisGroup.add(valueLabel);
            }

            axisGroup.add(zAxisGroup);

            scene.add(axisGroup);
            scene.add(gridGroup);

            debugLog('Added detailed coordinate axes with Z-up orientation and value labels');
        }

        // Update coordinate axes when Z-scale changes
        function updateCoordinateAxes() {
            // The axes themselves don't scale, but we need to update Z-value labels
            // This is handled by the applyZScale function which updates the surface groups
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            Object.values(surfaceGroups).forEach(group => {
                group.traverse((child) => {
                    if (child.isMesh) {
                        child.material.wireframe = wireframeMode;
                    }
                });
            });
            debugLog(`Wireframe mode: ${wireframeMode ? 'ON' : 'OFF'}`);
        }

        function toggleDebug() {
            debugMode = !debugMode;
            const debugPanel = document.getElementById('debug');
            debugPanel.style.display = debugMode ? 'block' : 'none';

            if (debugMode) {
                document.getElementById('debug-content').innerHTML = 'Debug mode enabled (Z-up coordinate system)<br>';
                debugLog('Debug panel opened');
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Main initialization function
        async function initApp() {
            try {
                console.log('Initializing Binary Polygon Surface Viewer with Z-up coordinate system...');

                document.getElementById('loading-detail').textContent = 'Loading Three.js library...';

                if (!checkThreeJS()) {
                    await loadThreeJS();
                }

                if (!checkThreeJS()) {
                    throw new Error('Three.js library failed to load');
                }

                console.log('Three.js loaded successfully, version:', THREE.REVISION);

                document.getElementById('loading-detail').textContent = 'Initializing 3D scene...';
                initScene();

                // Start animation loop
                animate();

                // Load data from GitHub
                document.getElementById('loading-detail').textContent = 'Loading surface data from GitHub...';
                const data = await loadGitHubData();

                document.getElementById('loading-detail').textContent = 'Processing surface data...';
                polygonData = data;

                document.getElementById('loading-detail').textContent = 'Creating 3D visualization...';
                createVisualization();

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';

                debugLog('Application initialized successfully with Z-up coordinate system');

            } catch (error) {
                console.error('Initialization failed:', error);
                showError('GitHub Loading Failed', error.message, error.stack);
            }
        }

        // Start application
        window.addEventListener('load', initApp);

        // ============= FILE IMPORT CODE (MOVED TO END) =============

        // Load data from GitHub URLs
        async function loadGitHubData() {
            const loadStartTime = performance.now();
            let lastError = null;

            for (let i = 0; i < GITHUB_URLS.length; i++) {
                const url = GITHUB_URLS[i];
                const urlType = url.includes('raw.githubusercontent.com') ? 'GitHub Raw' : 'JSDelivr CDN';

                try {
                    debugLog(`Attempting to load from ${urlType}: ${url}`);
                    document.getElementById('loading-detail').textContent = `Loading from ${urlType}...`;
                    document.getElementById('cdn-source').textContent = urlType;

                    const response = await fetch(url);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const buffer = await response.arrayBuffer();
                    const loadTime = performance.now() - loadStartTime;

                    fileMetadata = {
                        name: 'envelope_1.bin',
                        size: buffer.byteLength,
                        type: 'binary',
                        loadStartTime: loadStartTime,
                        loadTime: loadTime,
                        source: urlType,
                        url: url
                    };

                    debugLog(`Successfully loaded ${(buffer.byteLength / 1024 / 1024).toFixed(2)} MB from ${urlType}`);

                    document.getElementById('loading-detail').textContent = 'Parsing binary data...';
                    const data = parseBinaryFile(buffer);

                    document.getElementById('loading-detail').textContent = 'Validating data structure...';
                    validateData(data);

                    // Update load status
                    const statusElement = document.getElementById('load-status');
                    statusElement.textContent = `Loaded from ${urlType}`;
                    statusElement.className = 'load-status status-success';

                    return data;

                } catch (error) {
                    lastError = error;
                    console.warn(`Failed to load from ${urlType}:`, error.message);

                    // Update load status for failed attempt
                    const statusElement = document.getElementById('load-status');
                    statusElement.textContent = `Failed: ${urlType}`;
                    statusElement.className = 'load-status status-error';

                    // If this isn't the last URL, continue to next
                    if (i < GITHUB_URLS.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Brief delay between attempts
                        continue;
                    }
                }
            }

            // If we get here, all URLs failed
            throw new Error(`Failed to load from all GitHub sources. Last error: ${lastError?.message || 'Unknown error'}`);
        }

        // Binary file parser
        class BinaryParser {
            constructor(buffer) {
                this.buffer = buffer;
                this.view = new DataView(buffer);
                this.offset = 0;
            }

            readString(length) {
                const bytes = new Uint8Array(this.buffer, this.offset, length);
                this.offset += length;
                // Find null terminator and decode
                let str = '';
                for (let i = 0; i < bytes.length && bytes[i] !== 0; i++) {
                    str += String.fromCharCode(bytes[i]);
                }
                return str;
            }

            readUint32() {
                const value = this.view.getUint32(this.offset, true); // little endian
                this.offset += 4;
                return value;
            }

            readFloat32() {
                const value = this.view.getFloat32(this.offset, true); // little endian
                this.offset += 4;
                return value;
            }

            readUint8() {
                const value = this.view.getUint8(this.offset);
                this.offset += 1;
                return value;
            }

            readBytes(length) {
                const bytes = new Uint8Array(this.buffer, this.offset, length);
                this.offset += length;
                return bytes;
            }
        }

        // Parse binary file
        function parseBinaryFile(buffer) {
            const startTime = performance.now();
            const parser = new BinaryParser(buffer);

            // Read file header
            const magic = parser.readString(4);
            if (magic !== 'FLVP') {
                throw new Error(`Invalid binary format: expected 'FLVP', got '${magic}'`);
            }

            const version = parser.readUint32();
            const realization = parser.readUint32();
            const surfaceCount = parser.readUint32();

            debugLog(`Binary file header: version=${version}, realization=${realization}, surfaces=${surfaceCount}`);

            const surfaces = [];

            for (let i = 0; i < surfaceCount; i++) {
                debugLog(`Reading surface ${i + 1}/${surfaceCount}...`);

                // Read surface header
                const name = parser.readString(32);
                const id = parser.readUint32();
                const vertexCount = parser.readUint32();
                const faceCount = parser.readUint32();

                // Read color
                const r = parser.readUint8();
                const g = parser.readUint8();
                const b = parser.readUint8();
                parser.readUint8(); // padding
                const color = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;

                debugLog(`Surface '${name}': ${vertexCount} vertices, ${faceCount} faces, color=${color}`);

                // Read vertices
                const vertices = [];
                for (let v = 0; v < vertexCount; v++) {
                    const x = parser.readFloat32();
                    const y = parser.readFloat32();
                    const z = parser.readFloat32();
                    vertices.push([x, y, z]);
                }

                // Read faces
                const faces = [];
                for (let f = 0; f < faceCount; f++) {
                    const v0 = parser.readUint32();
                    const v1 = parser.readUint32();
                    const v2 = parser.readUint32();
                    faces.push([v0, v1, v2]);
                }

                surfaces.push({
                    facies_id: id,
                    facies_name: name,
                    color: color,
                    vertices: vertices,
                    faces: faces,
                    statistics: {
                        vertex_count: vertexCount,
                        face_count: faceCount
                    }
                });
            }

            const parseTime = performance.now() - startTime;
            debugLog(`Binary parsing completed in ${parseTime.toFixed(1)}ms`);

            return {
                metadata: {
                    realization: realization,
                    data_type: "binary_envelope_surfaces",
                    format_version: version.toString(),
                    total_statistics: {
                        total_surfaces: surfaceCount,
                        total_vertices: surfaces.reduce((sum, s) => sum + s.statistics.vertex_count, 0),
                        total_faces: surfaces.reduce((sum, s) => sum + s.statistics.face_count, 0)
                    },
                    parse_time_ms: parseTime
                },
                surfaces: surfaces
            };
        }
    </script>
</body>
</html>